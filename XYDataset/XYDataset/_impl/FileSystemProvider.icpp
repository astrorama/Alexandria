/**
 * @file FileSytemProvider.icpp
 *
 * @date Apr 14, 2014
 * @author Nicolas Morisset
 */

#ifdef FILESYSTEMPROVIDER_IMPL

#include <exception>
#include <boost/filesystem.hpp>
#include "XYDataset/XYDatasetIdentifierTraits.h"

namespace fs = boost::filesystem;

namespace XYDataset {

//-----------------------------------------------------------------------------
//                              Constructor
//-----------------------------------------------------------------------------

template <typename T>

FileSystemProvider<T>::FileSystemProvider(const std::string& root_path, std::unique_ptr<FileParser> parser)
                   : XYDatasetProvider<T>(), m_root_path(root_path), m_parser(std::move(parser)) {

  std::vector<std::string> string_vector{};

  // Make sure the group finishes with a "/" and only one
  size_t pos = m_root_path.find_last_not_of("/");
  if (  pos != m_root_path.length()-1) {
    m_root_path = m_root_path.substr(0, pos+1) + "/";
  }

  // Convert path to boost filesytem object
  fs::path fspath(m_root_path);
  if (!fs::exists(fspath)) {
    throw ElementsException() << "Root path not found : " << fspath;
  }

  // Get all files below the root directory
  if (fs::is_directory(fspath)) {
    fs::recursive_directory_iterator it {m_root_path};
    fs::recursive_directory_iterator endit;
    while(it != endit)
    {
      if (fs::is_regular_file(*it))
      {
        std::string dataset_name = m_parser->getName(it->path().string());
        // Remove the root part
        std::string str = it->path().string();
        str = str.substr(m_root_path.length(), str.length());
        // Remove filename
        size_t pos = str.find_last_of("/");
        std::string group = str.substr(0, pos+1);
        std::string qualified_name = group + dataset_name;
        // Fill up a map
        auto ret = m_map.insert(make_pair(qualified_name, it->path().string()));
        // Check for unique record
        if (!ret.second) {
          throw ElementsException() << "Qualified name can not be inserted "
                                    << "in the map. Qualify name : "
                                    << qualified_name
                                    << " Path :" << it->path().string();
        }
      }
      ++it;
    }
  }
  else {
    throw ElementsException() << " Root path : " << fspath.string() << " is not a directory!";
  }

}

//-----------------------------------------------------------------------------
//                             listContents function
//-----------------------------------------------------------------------------

template <typename T>
std::vector<std::string> FileSystemProvider<T>::listContents(const std::string& group) {

 std::string my_group = group;
 // Make sure the group finishes with a "/" and only one
 size_t pos = my_group.find_last_not_of("/");
 if (  pos != my_group.length()-1) {
   my_group = my_group.substr(0, pos+1) + "/";
 }
 // Make sure the group do not start with a "/"
 pos = my_group.find_first_not_of("/") ;
 if ( pos != 0) {
   my_group = my_group.substr(pos);
 }

 std::vector<std::string> qualified_name_vector{};
 std::string full_path = m_root_path + my_group;

 // Fill up vector with qualified name from the map
 // Insert all qualified name where path contains the group name at the
 // first position
 for (auto it : m_map ) {
     auto qualified_name = it.first;
      if (! qualified_name.find(my_group)) {
         qualified_name_vector.push_back(qualified_name);
     }
 } // Eof for

 return (qualified_name_vector);
}

//-----------------------------------------------------------------------------
//                             getDataset function
//-----------------------------------------------------------------------------

template <typename T>

std::unique_ptr<XYDataset> FileSystemProvider<T>::getDataset(const T & identifier) {

 std::string filename {};
 std::string qualifiedName = XYDatasetIdentifierTraits<T>::getQualifiedName(identifier);

 auto it = m_map.find(qualifiedName);
 if (it != m_map.end()) {
    filename = it->second;
 }

 return (m_parser->getDataset(filename));
}

} /* namespace XYDataset */

#endif /* FILESYSTEMPROVIDER_IMPL */
