#ifndef INTERPOLATION_IMPL
#error Please, include "MathUtils/interpolation/interpolation.h"
#endif

#include "AlexandriaKernel/index_sequence.h"
#include "MathUtils/interpolation/GridInterpolation.h"

namespace Euclid {
namespace MathUtils {

template <std::size_t, typename Seq>
struct InterpNAdapter;

template <std::size_t N, std::size_t... Is>
struct InterpNAdapter<N, _index_sequence<Is...>> : NAryFunction<N> {
  template <std::size_t>
  using Doubles = double;

  InterpNAdapter(const Coordinates<N>& grid, const NdArray::NdArray<double>& values, InterpolationType type, bool extrapolate)
      : m_interpn(std::tuple<std::vector<Doubles<Is>>...>{grid[Is]...}, values, extrapolate) {
    if (type != InterpolationType::LINEAR) {
      throw InterpolationException() << "Only linear interpolation is supported for N-dimensional grids";
    }
  }

  double operator()(Doubles<Is>... xn) const override {
    return m_interpn(xn...);
  }

  std::unique_ptr<NAryFunction<N>> clone() const override {
    return Euclid::make_unique<InterpNAdapter>(*this);
  }

  InterpNAdapter(const InterpNAdapter&) = default;

private:
  InterpN<Doubles<Is>...> m_interpn;
};

template <std::size_t N>
std::unique_ptr<NAryFunction<N>> interpn(const Coordinates<N>& grid, const NdArray::NdArray<double>& values, InterpolationType type,
                                         bool extrapolate) {
  return Euclid::make_unique<InterpNAdapter<N, _make_index_sequence<N>>>(grid, values, type, extrapolate);
}

}  // namespace MathUtils
}  // namespace Euclid
