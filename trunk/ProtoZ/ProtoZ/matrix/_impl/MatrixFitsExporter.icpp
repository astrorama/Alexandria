/** 
 * @file MatrixFitsExporter.cpp
 * @date February 1, 2014
 * @author Nikolaos Apostolakos
 */

#ifdef MATRIXFITSEXPORTER_IMPL

#include <memory>
#include <valarray>
#include <sstream>
#include <tuple>
#include <vector>
#include <CCfits/CCfits>
#include "ProtoZ/matrix/MatrixFitsExporter.h"

namespace ProtoZ {
namespace matrix {

template<typename T, typename... Axes>
void MatrixFitsExporter::exportMatrixAsFitsFile(const std::string& filename,
                                                const Matrix<T,Axes...>& matrix) {
  long naxis = matrix.rank();
  long naxes[sizeof...(Axes)];
  for (int i = 0; i < naxis; i++) {
    naxes[i] = matrix.m_axis_sizes[i];
  }

  remove(filename.c_str());
  std::unique_ptr<CCfits::FITS> pFits {new CCfits::FITS(filename, DOUBLE_IMG, naxis, naxes)};

  AxesHelper<Axes...>::addAxesKeywords(matrix.axesInfo(), pFits->pHDU(),
                                       TemplateLoopCounter<sizeof...(Axes)>{});
  AxesHelper<Axes...>::addAxesHdus(matrix.axesInfo(), *pFits,
                                   TemplateLoopCounter<sizeof...(Axes)>{});

  std::valarray<double> data(matrix.m_data.size());
  for (int i=0; i<matrix.m_data.size(); i++) {
    data[i] = matrix.m_data[i];
  }

  pFits->pHDU().write(1, data.size(), data);
} /* end of exportMatrixAsFitsFile() */

template<typename... Axes>
class MatrixFitsExporter::AxesHelper {

public:

  template<int I>
  static void addAxesKeywords(const std::tuple<AxisInfo<Axes>...>& axes,
                              CCfits::HDU& hdu, const TemplateLoopCounter<I>&) {
    std::stringstream ttype;
    ttype << "TTYPE" << I;
    std::string name = std::get<I-1>(axes).name();
    std::stringstream comment;
    comment << "Name of axis no " << I;
    addAxesKeywords(axes, hdu, TemplateLoopCounter<I-1>{});
    hdu.addKey(ttype.str(), name.c_str(), comment.str());
  }

  static void addAxesKeywords(const std::tuple<AxisInfo<Axes>...>&,
                              CCfits::HDU&, const TemplateLoopCounter<0>&) {
  }

  template<int I>
  static void addAxesHdus(const std::tuple<AxisInfo<Axes>...>& axes,
                          CCfits::FITS& fits, const TemplateLoopCounter<I>&) {
    addAxesHdus(axes, fits, TemplateLoopCounter<I-1>{});
    auto axisInfo = std::get<I-1>(axes);
    std::vector<std::string> values {};
    size_t longest {};
    for (int i=0; i<axisInfo.size(); i++) {
      std::stringstream valueString {};
      valueString << axisInfo.indexToValue(i);
      if (longest < valueString.str().size()) {
        longest = valueString.str().size();
      }
      values.push_back(valueString.str());
    }
    unsigned long rows {axisInfo.size()};
    std::string hduName {axisInfo.name()};
    std::vector<string> colName(1, "");
    std::vector<string> colForm(1, "");
    std::vector<string> colUnit(1, "");
    colName[0] = axisInfo.name();
    std::stringstream colFormatString {};
    colFormatString << "a" << longest;
    colForm[0] = colFormatString.str();
    colUnit[0] = "";
    CCfits::Table* newTable = fits.addTable(hduName,rows,colName,colForm,colUnit,CCfits::HduType::AsciiTbl);
     newTable->column(colName[0]).write(values,1);
  }

  static void addAxesHdus(const std::tuple<AxisInfo<Axes>...>&,
                          CCfits::FITS&, const TemplateLoopCounter<0>&) {
  }
}; /*  end of AxesHelper */

} /* namespace matrix */
} /* namespace ProtoZ */

#endif /* MATRIXFITSEXPORTER_IMPL */