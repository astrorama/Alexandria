/** 
 * @file ChMatrix/_impl/MatrixIterator.icpp
 * @date May 14, 2014
 * @author Nikolaos Apostolakos
 */

#include <algorithm>
#include "ElementsKernel/ElementsException.h"

namespace ChMatrix {

template<typename DataManager, typename... AxesTypes>
Matrix<DataManager, AxesTypes...>::iterator::iterator(
                                const Matrix<DataManager, AxesTypes...>& owner,
                                const data_iter_type& data_iter)
        : m_owner(owner), m_data_iter {data_iter} { }

template<typename DataManager, typename... AxesTypes>
auto Matrix<DataManager, AxesTypes...>::iterator::operator=(const iterator& other) -> iterator& {
  m_data_iter = other.m_data_iter;
  m_fixed_indices = other.m_fixed_indices;
  return *this;
}

template<typename DataManager, typename... AxesTypes>
auto Matrix<DataManager, AxesTypes...>::iterator::operator++() -> iterator& {
  ++m_data_iter;
  if (!m_fixed_indices.empty()) {
    for (auto& fixed_index_pair : m_fixed_indices) {
      size_t axis = fixed_index_pair.first;
      size_t fixed_index = fixed_index_pair.second;
      forwardToIndex(axis, fixed_index);
    }
    // Because we make big steps there is the possibility we went after the end.
    // In this case we set the iterator to the end.
    auto end_iter = DataManagerTraits<DataManager>::end(*(m_owner.m_data_manager));
    if (m_data_iter > end_iter) {
      m_data_iter = end_iter;
    }
  }
  return *this;
}

template<typename DataManager, typename... AxesTypes>
auto Matrix<DataManager, AxesTypes...>::iterator::operator*() -> data_type& {
  return *m_data_iter;
}

template<typename DataManager, typename... AxesTypes>
bool Matrix<DataManager, AxesTypes...>::iterator::operator==(const iterator& other) const {
  return m_data_iter == other.m_data_iter;
}

template<typename DataManager, typename... AxesTypes>
bool Matrix<DataManager, AxesTypes...>::iterator::operator!=(const iterator& other) const {
  return m_data_iter != other.m_data_iter;
}

template<typename DataManager, typename... AxesTypes>
template<int I>
size_t Matrix<DataManager, AxesTypes...>::iterator::axisIndex() const {
  size_t index = m_data_iter - DataManagerTraits<DataManager>::begin(*(m_owner.m_data_manager));
  return m_owner.m_index_helper.axisIndex(I, index);
}

template<typename DataManager, typename... AxesTypes>
template<int I>
auto Matrix<DataManager, AxesTypes...>::iterator::axisValue() const -> const axis_type<I>& {
  size_t index = axisIndex<I>();
  return std::get<I>(m_owner.m_axes)[index];
}

template<typename DataManager, typename... AxesTypes>
template<int I>
auto Matrix<DataManager, AxesTypes...>::iterator::fixAxisByIndex(size_t index) -> iterator& {
  if (index >= m_owner.axisInfo<I>().size()) {
    throw ElementsException() << "Index (" << index << ") out of axis " 
                              << m_owner.axisInfo<I>().name() << " size ("
                              << m_owner.axisInfo<I>().size() << ")";
  }
  m_fixed_indices[I] = index;
  forwardToIndex(I, index);
  return *this;
}

template<typename DataManager, typename... AxesTypes>
template<int I>
auto Matrix<DataManager, AxesTypes...>::iterator::fixAxisByValue(const axis_type<I>& value) -> iterator& {
  auto axis_info = m_owner.axisInfo<I>();
  auto iter = std::find(axis_info.begin(), axis_info.end(), value);
  if (iter == axis_info.end()) {
    throw ElementsException() << "Failed to fix axis " << m_owner.axisInfo<I>().name()
                              << " (given value not found)";
  }
  return fixAxisByIndex<I>(iter - axis_info.begin());
}

template<typename DataManager, typename... AxesTypes>
void Matrix<DataManager, AxesTypes...>::iterator::forwardToIndex(size_t axis, size_t fixed_index) {
  size_t current_size = m_data_iter - DataManagerTraits<DataManager>::begin(*(m_owner.m_data_manager));
  size_t current_index = m_owner.m_index_helper.axisIndex(axis, current_size);
  if (fixed_index != current_index) {
    size_t axis_factor = m_owner.m_index_helper.m_axes_index_factors[axis];
    size_t distance = (fixed_index > current_index)
          ? fixed_index - current_index
          : m_owner.m_index_helper.m_axes_sizes[axis] + fixed_index - current_index;
    m_data_iter += distance * axis_factor;
  }
}

} // end of ChMatrix namespace