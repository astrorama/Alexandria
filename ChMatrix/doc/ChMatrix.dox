namespace ChMatrix {

/** \page chmatrix ChMatrix module

\tableofcontents

The ChMatrix module provides a highly configurable, multi-dimensional matrix,
which provides extended functionality related with the information about its
axes (in an efficient way). Note that this module is **NOT** a mathematical
module. The provided Matrix is closer to a collection structure than a
mathematical matrix and no mathematical functionality is provided.

This page contains multiple code examples. To improve readability, the following
two lines are assumed for each example:

\code{.cpp}
  using namespace ChMatrix;
  using namespace std;
\endcode

Note that these lines are used to make the example code more readable and they
will introduce all the symbols of the ChMatrix and std namespaces in the global
namespace, so they must be sparingly used.

At the bottom of this page can be found the entire code of the examples as a
single file.

\section datamodel ChMatrix data model

The ChMatrix data model consists of three concepts, the AxisInfo class, which
contains information of a matrix axis, the **DataManager**, which handles the
matrix cell values and the Matrix class, which combines everything together. The
following sections describe these concepts and provide examples of how to use
them.

\subsection axisinfo AxisInfo class

Each axis of a Matrix can be seen as a collection of (zero based) indexed knots
(knot_0, knot_1, knot_2 etc). The index of each knot represents the coordinate
of the matrix cells and the value of the knot represents the world value of the
axis. For example, an axis representing the wavelength might have the following
knots:

| Knot Index | Knot Value |
|:----------:|:----------:|
|      0     |    3000    |
|      1     |    3500    |
|      2     |    4000    |
|      3     |    4500    |
|      4     |    5000    |

Using the above axis, to access the matrix cells which have wavelength equal
with 4000, the wavelength axis coordinate must be 2.

\subsubsection axisinfocreation Creating AxisInfo objects

Constructing the AxisInfo object representing the above axis can be done using
the following code:

\code {.cpp}
  vector<int> knot_values {3000, 3500, 4000, 4500, 5000};
  AxisInfo<int> wavelength_axis {"Wavelength", move(knot_values)};
\endcode

In the code above one can make the following observations:

- To support axes with knots of different types, the AxisInfo class gets this
  type as a template parameter. In the example above the type chosen is `int` 
  (`AxisInfo<int>`). To use knots of `string` type, the definitions should be
  `AxisInfo<string>`. Note that user defined types are also supported.

- The first parameter of the AxisInfo constructor is a string which describes
  the *axis name*. The axes of a Matrix must have unique names.

- The values of the knots must be given during construction. This is because the
  AxisInfo class is immutable and further modifications are not allowed.

- The number of knots is not given explicitly, but it is inferred from the
  vector containing the knot values.

\subsubsection axisinfoaccess Using AxisInfo objects

Retrieving the axis information from an AxisInfo object is trivial. The knot
values can be accessed either by using an iterator or directly, by using the
brackets (`[]`) operator, as demonstrated in the following example:

\code{.cpp}
  // Getting the axis name
  cout << "Axis name : " << wavelength_axis.name() << "\n";
  
  // Getting the number of knots
  cout << "Number of knots : " << wavelength_axis.size() << "\n";
  
  // Accessing a knot value directly using its (zero based) index
  cout << "Second knot value : " << wavelength_axis[1] << "\n";
  
  // Accessing the knots using the iterator
  cout << "All knot values : ( ";
  for (auto& knot_value : wavelength_axis) {
    cout << knot_value << " ";
  }
  cout << ")\n";
\endcode

Output:

\code
Axis name : Wavelength
Number of knots : 5
Second knot value : 3500
All knot values : ( 3000 3500 4000 4500 5000 )
\endcode

\subsection datamanager DataManager interface

The purpose of the Matrix class is not to re-implement a matrix representation
in the memory. Instead, it delegates the memory management of the cell data to
an object of the type given as the `DataManager` template parameter. This
delegation is not done directly (to provide more flexibility). Instead, every
time the Matrix wants to access the DataManager, it uses the corresponding
specialization of the traits class DataManagerTraits.

\subsubsection vectordatamanager std::vector as DataManager

Because the `std::vector` type can be used in many different scenarios as the
Matrix DataManager, the specialization of the DataManagerTraits is provided by
ChMatrix module by default. Until being more familiar with the ChMatrix module,
and to see directly how a DataManager can be used by the Matrix class, one can
skip directly to the \ref matrix section, and return later here for studying the
details of DataManagerTraits.

\subsubsection datamanagertraits Implementing a DataManagerTraits specialization

The DataManagerTraits defines the behavior a DataManager type must provide, so
it can be used by the Matrix class. In other words, it provides the interface of
the DataManager for the Matrix to use. This is done so a type which provides a
different interface can be used as a DataManager, by just defining a
specialization of the DataManagerTraits. Note that the DataManagerTraits default
behavior is to delegate all the operations to the type used as a DataManager. If
the type is compliant with this interface, there is no need for defining the
DataManagerTraits specialization.

As an example, imagine that we want to use as DataManager an *old-style* class
which uses pointers to handle an area in the memory:

\code{.cpp}
template <typename T>
class MemoryManager {
public:
  MemoryManager(size_t size) {
    m_size = size;
    m_start = reinterpret_cast<T*>(malloc(m_size * sizeof(T)));
  }
  ~MemoryManager() {
    free(m_start);
  }
  size_t getSize() {
    return m_size;
  }
  T* getPointerToStart() {
    return m_start;
  }
private:
  size_t m_size;
  T* m_start;
};
\endcode

As can be seen above, the `MemoryManager` class uses `malloc` to allocate enough
memory for the required number of objects, and frees it when it is destroyed. It
provides direct access to the memory by returning a pointer to the beginning of
it (note that the above implementation is incomplete and only for demonstration
purposes). The `MemoryManager` class is not compliant with the DataManagerTraits
interface, so, if we want to use it as a Matrix DataManager, we need to provide
a specialization. This can be done with the following code:

\code{.cpp}
namespace ChMatrix {

template<typename T>
struct DataManagerTraits<MemoryManager<T>> {
  typedef T data_type;
  typedef T* iterator;
  static unique_ptr<MemoryManager<T>> factory(size_t s) {
    return unique_ptr<MemoryManager<T>>{new MemoryManager<T>{s}};
  }
  static size_t size(const MemoryManager<T>& m) {
    return m.getSize();
  }
  static iterator begin(MemoryManager<T>& m) {
    return m.getPointerToStart();
  }
  static iterator end(MemoryManager<T>& m) {
    return m.getPointerToStart() + m.getSize();
  }
  static const bool enable_boost_serialize = false;
};

} // End of ChMatrix namespace
\endcode

The DataManagerTraits specializations, as seen above, must be defined in the
ChMatrix namespace. They must contain the following definitions:

- type DataManagerTraits::data_type<br/>
  The type of the data kept by the `DataManager`. For our example this is the
  template type `T` of the `MemoryManager`.

- type DataManagerTraits::iterator<br/>
  The iterator type which is used to iterate through the data kept in the data
  manager. For our example we define a pointer to the type `T` (pointers behave
  as iterators).

- function DataManagerTraits::factory()<br/>
  Creates a new `DataManager` instance, which manages the given number of data.
  For our example we call the constructor of the `MemoryManager` class, which
  will allocate the required memory.

- function DataManagerTraits::size()<br/>
  Returns the number of data managed by the given `DataManager`. For our example
  we call the `getSize()` method of the `MemoryManager`.

- function DataManagerTraits::begin()<br/>
  Returns an iterator pointing to the first element managed by the DataManager.
  For our example we return a pointer to the beginning of the allocated memory.

- function DataManagerTraits::end()<br/>
  Returns an iterator pointing right after the last element managed by the
  DataManager. For our example we use the `getPointerToStart()` and `getSize()`
  methods to return a pointer right after the allocated memory.

- constant DataManagerTraits::enable_boost_serialize<br/>
  Indicates if the DataManager is boost serializable (this is explained later
  in the \ref serialization section).

Note that it is not obligatory to implement all the above, but only what is
actually being used. For example, the Matrix class provides an alternative
constructor which does not use the `factory()` method, but it gets the
`DataManager` instance as a parameter. This can be used if the managed type
does not have a meaningful default value.

Furthermore, there is no requirement for the `DataManager` to actually keep the
data in the memory. An implementation can provide an iterator which will
calculate the data *on the fly*. Such types of DataManagers are too application
specific, so they are not described further here.

\subsection matrix Matrix class

As explained earlier, the Matrix class is combining together the concepts of the
DataManager (which keeps the Matrix data) and the information of the
corresponding axes (described as AxisInfo objects).

\subsubsection creatematrix Creating Matrix objects

Each Matrix object has a fixed parameter space, meaning that, once created, its
axes cannot be modified. For this reason, the AxisInfo objects representing the
Matrix axes must be created beforehand. The following code demonstrates how to
create a three dimensional matrix:

\code{.cpp}
// Create the axes descriptions
AxisInfo<int> int_axis {"Integers", {1, 2, 3, 4, 5}};
AxisInfo<double> double_axis {"Doubles", {0.1, 0.2}};
AxisInfo<string> string_axis {"Strings", {"one", "two", "three"}};

// Create a matrix with integer data
Matrix<vector<int>, int, double, string> matrix {int_axis, double_axis, string_axis};
\endcode

The first template parameter of the Matrix class defines the `DataManager` type
that the Matrix will use. In the example above this type is `vector<int>`, which
shows that the Matrix will keep integer values and it will use a vector as the
DataManager.

The rest of the template parameters define the types of the axes world values.
In our example the first axis has integer knots, the second double knots and the
third strings. Note that the axes knots can be of any type, even of user defined
types. The axes given as parameters to the constructor must be of the correct
types, otherwise the compilation will fail.

In the example above, the vector for keeping the matrix data is automatically
created by the constructor, by using the DataManagerTraits::factory() method.
For the case of a `DataManager` type which does not provide the `factory()`
method in its DataManagerTraits specialization, or for the case some default
initialization values are required, the Matrix class provides a second
constructor:

\code{.cpp}
  // Create and initialize the DataManager instance
  unique_ptr<vector<int>> data_manager {new vector<int>{}};
  for (int i=0; i<30; ++i) {
    data_manager->push_back(i);
  }
  // Create the Matrix object
  Matrix<vector<int>, int, double, string> initialized_matrix
                    {move(data_manager), int_axis, double_axis, string_axis};
\endcode

The DataManager instance is passed as a `unique_ptr` to indicate the change of
ownership (the Matrix instance will own the data manager from that moment on).
Note that the size of the given `DataManager` must be the size required
according the axes sizes. If a manager of wrong size is given a runtime
exception is thrown.

The last case of creating Matrices is when one already has a Matrix instance and
want to create a second Matrix with the same parameter space (axes). This is a
common operation, so it is supported by the Matrix API as demonstrated by the
following code:

\code{.cpp}
Matrix<vector<bool>, int, double, string> bool_matrix {matrix.axisInfoTuple()};
\endcode

The code above creates a new matrix of booleans, with the same axes like the
parameter. Note that only the axes number and types need to match between the
two matrices. The new matrix DataManager can be of any type.

\subsubsection matrixinformation Retrieving Matrix information

The Matrix class provides a range of methods for retrieving its information, as
demonstrated by the following code:

\code{.cpp}
  // Get the matrix dimensionality
  cout << "Dimensionality: " << matrix.rank() << "\n";

  // Get the total number of cells of the matrix
  cout << "Total number of cells: " << matrix.size() << "\n";

  // Retrieve information about the third axis
  auto& third_axis = matrix.axisInfo<2>();

  // Print the axis information
  cout << "Third axis name: " << third_axis.name() << "\n";
  cout << "Third axis knots: ";
  for (auto& knot : third_axis) {
    cout << knot << " ";
  }
\endcode

Output:

\code
Dimensionality: 3
Total number of cells: 30
Third axis name: Strings
Third axis knots: one two three
\endcode

Note that the axes information is retrieved by the Matrix::axisInfo() method,
which returns a reference to an AxisInfo object. The axis to get the information
for is specified with an integer template parameter representing its (zero
based) index.

\subsubsection directmatrixaccess Direct cell access

The Matrix cells can be directly accessed based on their coordinates, by using
the parenthesis operator. This operator returns a reference to the cell value
which can be used both for reading and writing:

\code{.cpp}
  // Set the value of a specific cell
  matrix(2, 0, 1) = 50;
  // Read the value of a specific cell
  cout << matrix(2, 0, 1) << "\n";
\endcode

Note that the parenthesis operator will not perform any bound checks to the
given indices. If any of the indices is out of bounds will result to *undefined
behavior*. For cases the indices are not guaranteed to be in bounds, the
alternative method at() should be used (with the implied performance cost),
which behaves the same way like the parenthesis operator, but it throws an
ElementsException in the case any of the indices is out of bounds:

\code{.cpp}
  size_t coord = .....;
  try {
    // Set the value of a specific cell
    matrix.at(coord, 0, 1) = 50;
    // Read the value of a specific cell
    cout << matrix.at(coord, 0, 1) << "\n";
  } catch (ElementsException e) {
    cout << e.what() << "\n";
  }
\endcode

In the above example if the coord variable has a value less than the first axis
size the code will print the cell value. If it is out of bounds, it will print
the message of the exception.

Accessing the matrix cells by using the parenthesis operator and the at() method
is very useful for accessing a single cell of which the coordinates are known at
the time of the call. This access though includes an overhead of the coordinates
translation, so the use of the Matrix iterator (described bellow) is recommended
for any case a big number of cells is accessed.

\subsubsection matrixiterator Matrix iterator

The second way to access the Matrix cells, both for reading and writing, is by
using the Matrix iterator. This method is the most efficient because it does not
imply any overhead related with axes management. For example, the following code
is almost as fast as accessing directly the vector keeping the values:

\code{.cpp}
  // Set all the matrix values
  int counter {0};
  for (auto& cell : matrix) {
    cell = ++counter;
  }
  // Print all the matrix cells
  cout << "Matrix cells: ";
  for (auto& cell : matrix) {
    cout << cell << " ";
  }
\endcode

Output:

\code
Matrix cells: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
\endcode

The order the cells are iterated is such so that the first axis varies the
fastest and the last the slowest. Note that using the iterator for accessing the
matrix cells is the most efficient way, but it does not provide any information
about the axes of each cell. This information can be retrieved by using the
special methods of the Matrix::iterator when needed (which implies some
computing overhead):

\code{.cpp}
  // Print detailed information for each cell
  for (auto iter=matrix.begin(); iter!=matrix.end(); ++iter) {
    cout << "Cell (" << iter.axisValue<0>() << ", " << iter.axisValue<1>()
         << ", " << iter.axisValue<2>() << "): " << *iter << "\n";
  }
\endcode

Output:

\code
Cell (1, 0.1, one): 1
Cell (2, 0.1, one): 2
Cell (3, 0.1, one): 3
Cell (4, 0.1, one): 4
Cell (5, 0.1, one): 5
Cell (1, 0.2, one): 6
Cell (2, 0.2, one): 7
Cell (3, 0.2, one): 8
Cell (4, 0.2, one): 9
Cell (5, 0.2, one): 10
Cell (1, 0.1, two): 11
Cell (2, 0.1, two): 12
Cell (3, 0.1, two): 13
Cell (4, 0.1, two): 14
Cell (5, 0.1, two): 15
Cell (1, 0.2, two): 16
Cell (2, 0.2, two): 17
Cell (3, 0.2, two): 18
Cell (4, 0.2, two): 19
Cell (5, 0.2, two): 20
Cell (1, 0.1, three): 21
Cell (2, 0.1, three): 22
Cell (3, 0.1, three): 23
Cell (4, 0.1, three): 24
Cell (5, 0.1, three): 25
Cell (1, 0.2, three): 26
Cell (2, 0.2, three): 27
Cell (3, 0.2, three): 28
Cell (4, 0.2, three): 29
Cell (5, 0.2, three): 30
\endcode

The methods provided by the iterator for accessing the axes information are the
Matrix::iterator::axisIndex(), which returns the related coordinate, and the
Matrix::iterator::axisValue(), which returns the world value of the axis knot.
Both methods receive the axis (zero based) index as an integer template
parameter. Note that the overhead of the second method is higher than the one of
the first, so it should be avoided in cases performance is an issue.

\subsubsection matrixslicing Matrix slicing

The ChMatrix module provides very efficient iteration over slices of a Matrix.
This is provided by the Matrix::iterator::fixAxisByIndex() and
Matrix::iterator::fixAxisByValue() methods, as demonstrated by the following
code:

\code{.cpp}
  // Get an iterator and fix the third axis
  auto iter = matrix.begin();
  iter.fixAxisByValue<2>("two");

  // Print detailed information for each cell
  do {
    cout << "Cell (" << iter.axisValue<0>() << ", " << iter.axisValue<1>()
         << ", " << iter.axisValue<2>() << "): " << *iter << "\n";
  } while (++iter != matrix.end());
\endcode

Output:

\code
Cell (1, 0.1, two): 11
Cell (2, 0.1, two): 12
Cell (3, 0.1, two): 13
Cell (4, 0.1, two): 14
Cell (5, 0.1, two): 15
Cell (1, 0.2, two): 16
Cell (2, 0.2, two): 17
Cell (3, 0.2, two): 18
Cell (4, 0.2, two): 19
Cell (5, 0.2, two): 20
\endcode

When a method for fixing an axis is called, the iterator moves to the next cell
with the given axis coordinate (or stays where it is if the current cell has
this coordinate). Increasing further the iterator will move it only through the
cells of the slice.

The functions for fixing an iterators axes can be chained to fix more than one
axes. For example, if in the previous code we had used:

\code{.cpp}
iter.fixAxisByValue<2>("two").fixAxisByIndex<0>(2).fixAxisByValue<1>(.1);
\endcode

we would get the following output:

\code
Cell (3, 0.1, two): 13
\endcode

The order in which the axes are fixed is not important, but keep in mind that if
the current cell does not have the requested axis coordinate the iterator is
shifted. For this reason it is best to fix the iterator axes right after
retrieving the iterator with the Matrix::begin() method. If an axis is fixed a
second time, the iterator will ignore the first fixing and will iterate through
the new slice.

\section serialization Matrix I/O

To be able to import and export Matrix objects, the ChMatrix module provides by
default support for binary boost serialization. This support is enabled by
including the `ChMatrix/serialize.h` file:

\code{.cpp}
#include "ChMatrix/serialize.h"
\endcode

\subsection defaultserialization Default Matrix Serialization

For the simple case that a vector is used as a `DataManager` and the cell type,
as well as all the axes types, are boost serializable, serialization of the
matrices can work *out-of-the-box*:

\code{.cpp}
  stringstream stream {};
  binaryExport(stream, matrix);
  auto stream_matrix = binaryImport<vector<int>, int, double, string>(stream);
\endcode

To be more flexible, the ChMatrix module provides Matrix serialization to
generic streams. To make the example more readable a string stream is used, but
it can be easily replaced with file streams to support permanent storage, or by
socket streams to transfer matrices via the network.

\subsection axisserialization Non-Default Axis Serialization

The above example works without any input from the user because all the axes
have types which are boost serializable. If an axis had a user defined type the
compilation would fail, as boost would not know how to serialize its values.
This is easily fixed by implementing the required methods to make the user
defined type serializable. More information can be found in the boost
serialization documentation, which can be found
[here](http://www.boost.org/doc/libs/1_55_0/libs/serialization/doc/index.html).

\subsection datamanagerserialization Custom DataManager Serialization

Similarly with the axes types, the `DataManager` type of a matrix must be boost
serializable, otherwise it will not be possible to serialize the matrix. By
default all the DataManagers are considered not serializable by the ChMatrix
module. To enable serialization for a specific DataManager, except of defining
the related boost::serialization methods, the related specialization of the
DataManagerTraits must have the enable_boost_serializable flag set to true.

By default the ChMatrix module enables serialization only for vectors of types
which are boost serializable.

\section apispecialization Specializing the Matrix API

From the examples above can be seen that the API of the ChMatrix module is quite
verbose. This is because of the flexibility the API provides, which leads in
lengthy template definitions. In real life applications though, there are many
cases that a set of (different cell type) matrices is required for a fixed
parameter space. The following is a suggestion of how to simplify the use of the
ChMatrix API for these cases.

\subsection axesorder Defining the axes order

To avoid the error prone use of integers as axes indices for all the methods
requiring them as a template parameter, an enumeration can be used, so more
meaningful names will replace them:

\code{.cpp}
enum {
  INT_AXIS = 0,
  DOUBLE_AXIS = 1,
  STRING_AXIS = 2
};
\endcode

Note that an anonymous plain enum has been used. This is because we want to be
able to use the conversion of the enumeration name to integer directly, without
having to perform casts (as is required by the enum class).

\subsection matrixspecialization Defining a Matrix specialization

To avoid repetition of the lengthy Matrix declarations a specialized alias can
be used:

\code{.cpp}
template <typename CellType>
using MyMatrix = Matrix<vector<CellType>, int, double, string>;
\endcode

The above definition assumes that all the matrices will use a vector as a
`DataManager` and allows only for further customization of the matrix cells
type. If different `DataManagers` are to be used, the following (more generic)
definition can be used:

\code{.cpp}
template <typename DataManager>
using MyMatrix = Matrix<DataManager, int, double, string>;
\endcode

\subsection binaryimportspecialization binaryImport() specialization

If serialization is to be used, it is recommended to wrap the binaryImport()
method with a more specialized templated function. This is because this method
cannot infer the Matrix template parameters (there is no matrix argument), with
result lengthy calls. The following code can simplify that:

\code{.cpp}
template <typename T>
MyMatrix<T> myBinaryImport(istream& in) {
  return binaryImport<vector<T>, int, double, string>(in);
}
\endcode

Note that, on the contrary, the binaryExport() method can infer all the template
parameters from its arguments, so no specialization is required.

\subsection specializationuse Using the specialized types

The following code demonstrates how the code using the above specializations
looks like. Note that the same examples like the previous sections are used, to
make easier the comparison.

\code{.cpp}
  // Create the AxisInfo objects (same as before)
  AxisInfo<int> int_axis {"Integers", {1, 2, 3, 4, 5}};
  AxisInfo<double> double_axis {"Doubles", {0.1, 0.2}};
  AxisInfo<string> string_axis {"Strings", {"one", "two", "three"}};
  
  // Create a matrix with integer data
  MyMatrix<int> matrix {int_axis, double_axis, string_axis};
  
  // Print all the nodes of the string axis
  cout << "String axis knots:";
  for (auto& knot : matrix.axisInfo<STRING_AXIS>()) {
    cout << " " << knot;
  }
  cout << "\n";
  
  // Get an iterator and fix two axes
  auto iter = matrix.begin();
  iter.fixAxisByValue<STRING_AXIS>("two").fixAxisByIndex<INT_AXIS>(3);
  
  // Print some info about each cell
  do {
    cout << "Double axis coord: " << iter.axisIndex<DOUBLE_AXIS>() << "\n";
    cout << "Double axis knot value: " << iter.axisValue<DOUBLE_AXIS>() << "\n";
  } while (++iter != matrix.end());
  
  // Write the matrix in a string stream and then read it back
  stringstream stream {};
  binaryExport(stream, matrix);
  auto stream_matrix = myBinaryImport<int>(stream);
  
  // Create a matrix to keep strings
  MyMatrix<string> string_matrix = {matrix.axisInfoTuple()};
\endcode

\section fullcode Full example code

\code{.cpp}
#include <iostream>
#include <vector>
#include <sstream>
#include "ChMatrix/Matrix.h"
#include "ChMatrix/serialize.h"

using namespace ChMatrix;
using namespace std;

// /////////////////////////////////////
// Definitions for custom DataManager
// /////////////////////////////////////

template <typename T>
class MemoryManager {
public:
  MemoryManager(size_t size) {
    m_size = size;
    m_start = reinterpret_cast<T*>(malloc(m_size * sizeof(T)));
  }
  ~MemoryManager() {
    free(m_start);
  }
  size_t getSize() {
    return m_size;
  }
  T* getPointerToStart() {
    return m_start;
  }
private:
  size_t m_size;
  T* m_start;
};

namespace ChMatrix {

template<typename T>
struct DataManagerTraits<MemoryManager<T>> {
  typedef T data_type;
  typedef T* iterator;
  static unique_ptr<MemoryManager<T>> factory(size_t s) {
    return unique_ptr<MemoryManager<T>>{new MemoryManager<T>{s}};
  }
  static size_t size(const MemoryManager<T>& m) {
    return m.getSize();
  }
  static iterator begin(MemoryManager<T>& m) {
    return m.getPointerToStart();
  }
  static iterator end(MemoryManager<T>& m) {
    return m.getPointerToStart() + m.getSize();
  }
  static const bool enable_boost_serialize = false;
};

} // End of ChMatrix namespace

// /////////////////////////////////////////
// End of custom DataManager definitions
// /////////////////////////////////////////

// ///////////////////////////////////////////////////
// Definitions for specializing the Matrix API
// ///////////////////////////////////////////////////

enum {
  INT_AXIS = 0,
  DOUBLE_AXIS = 1,
  STRING_AXIS = 2
};

template <typename CellType>
using MyMatrix = Matrix<vector<CellType>, int, double, string>;

template <typename T>
MyMatrix<T> myBinaryImport(istream& in) {
  return binaryImport<vector<T>, int, double, string>(in);
}

// ///////////////////////////////////////////////////
// End of definitions for specializing the Matrix API
// ///////////////////////////////////////////////////

int main() {
  
  // /////////////////////////////////////////
  // Creating AxisInfo objects
  // /////////////////////////////////////////
  cout << "\nCreating AxisInfo objects\n";
  
  vector<int> knot_values {3000, 3500, 4000, 4500, 5000};
  AxisInfo<int> wavelength_axis {"Wavelength", move(knot_values)};
  
  // /////////////////////////////////////////
  // Using AxisInfo objects
  // /////////////////////////////////////////
  cout << "\nUsing AxisInfo objects\n";
  
  // Getting the axis name
  cout << "Axis name : " << wavelength_axis.name() << "\n";
  // Getting the number of knots
  cout << "Number of knots : " << wavelength_axis.size() << "\n";
  // Accessing a knot value directly using its (zero based) index
  cout << "Second knot value : " << wavelength_axis[1] << "\n";
  // Accessing the knots using the iterator
  cout << "All knot values : ( ";
  for (auto& knot_value : wavelength_axis) {
    cout << knot_value << " ";
  }
  cout << ")\n";
  
  // /////////////////////////////////////////
  // Using custom DataManager
  // /////////////////////////////////////////
  cout << "\nUsing custom DataManager\n";
  
  Matrix<MemoryManager<double>, int> custom_dm_matrix { wavelength_axis };
  
  // /////////////////////////////////////////
  // Creating Matrix objects
  // /////////////////////////////////////////
  cout << "\nCreating Matrix objects\n";
  
  // Create the axes descriptions
  AxisInfo<int> int_axis {"Integers", {1, 2, 3, 4, 5}};
  AxisInfo<double> double_axis {"Doubles", {0.1, 0.2}};
  AxisInfo<string> string_axis {"Strings", {"one", "two", "three"}};
  
  // Create a matrix with integer data
  Matrix<vector<int>, int, double, string> matrix {int_axis, double_axis, string_axis};
  
  // Create and initialize the DataManager instance
  unique_ptr<vector<int>> data_manager {new vector<int>{}};
  for (int i=0; i<30; ++i) {
    data_manager->push_back(i);
  }
  
  // Create the Matrix object with the initialized DataManager
  Matrix<vector<int>, int, double, string> initialized_matrix
                    {move(data_manager), int_axis, double_axis, string_axis};
  
  // Create matrix with same parameter space
  Matrix<vector<bool>, int, double, string> bool_matrix {matrix.axisInfoTuple()};
  
  // /////////////////////////////////////////
  // Retrieving Matrix information
  // /////////////////////////////////////////
  cout << "\nRetrieving Matrix information\n";
  
  // Get the matrix dimensionality
  cout << "Dimensionality: " << matrix.rank() << "\n";
  
  // Get the total number of cells of the matrix
  cout << "Total number of cells: " << matrix.size() << "\n";
  
  // Retrieve information about the third axis
  auto& third_axis = matrix.axisInfo<2>();
  
  // Print the axis information
  cout << "Third axis name: " << third_axis.name() << "\n";
  cout << "Third axis knots: ";
  for (auto& knot : third_axis) {
    cout << knot << " ";
  }
  
  // /////////////////////////////////////////
  // Direct cell access
  // /////////////////////////////////////////
  cout << "\nDirect cell access\n";
  
  // Set the value of a specific cell
  matrix(2, 0, 1) = 50;
  // Read the value of a specific cell
  cout << "Matrix cell (2, 0, 1):" << matrix(2, 0, 1) << "\n";
  
  // Calling at() with in bounds coordinates
  size_t coord = 1;
  try {
    // Set the value of a specific cell
    matrix.at(coord, 0, 1) = 50;
    // Read the value of a specific cell
    cout << "Matrix cell (" << coord << ", 0, 1):" << matrix.at(coord, 0, 1) << "\n";
  } catch (ElementsException e) {
    cout << e.what() << "\n";
  }
  
  // Calling at() with out of bounds coordinates
  coord = 20;
  try {
    // Set the value of a specific cell
    matrix.at(coord, 0, 1) = 50;
    // Read the value of a specific cell
    cout << "Matrix cell (" << coord << ", 0, 1):" << matrix.at(coord, 0, 1) << "\n";
  } catch (ElementsException e) {
    cout << e.what() << "\n";
  }

  // /////////////////////////////////////////
  // Matrix iterator
  // /////////////////////////////////////////
  cout << "\nMatrix iterator\n";
  
  // Set all the matrix values
  int counter {0};
  for (auto& cell : matrix) {
    cell = ++counter;
  }
  // Print all the matrix cells
  cout << "Matrix cells: ";
  for (auto& cell : matrix) {
    cout << cell << " ";
  }
  cout << '\n';
  
  // Print detailed information for each cell
  for (auto iter=matrix.begin(); iter!=matrix.end(); ++iter) {
    cout << "Cell (" << iter.axisValue<0>() << ", " << iter.axisValue<1>()
         << ", " << iter.axisValue<2>() << "): " << *iter << "\n";
  }

  // /////////////////////////////////////////
  // Matrix slicing
  // /////////////////////////////////////////
  cout << "\nMatrix slicing\n";
  
  // Get an iterator and fix the third axis
  cout << "One axis fixed\n";
  auto iter = matrix.begin();
  iter.fixAxisByValue<2>("two");
  
  // Print detailed information for each cell
  do {
    cout << "Cell (" << iter.axisValue<0>() << ", " << iter.axisValue<1>()
         << ", " << iter.axisValue<2>() << "): " << *iter << "\n";
  } while (++iter != matrix.end());
  
  cout << "Three axes fixed\n";
  iter = matrix.begin();
  iter.fixAxisByValue<2>("two").fixAxisByIndex<0>(2).fixAxisByValue<1>(.1);
  
  // Print detailed information for each cell
  do {
    cout << "Cell (" << iter.axisValue<0>() << ", " << iter.axisValue<1>()
         << ", " << iter.axisValue<2>() << "): " << *iter << "\n";
  } while (++iter != matrix.end());

  // /////////////////////////////////////////
  // Default Matrix Serialization
  // /////////////////////////////////////////
  cout << "\nDefault Matrix Serialization\n";
  
  stringstream stream {};
  binaryExport(stream, matrix);
  auto stream_matrix = binaryImport<vector<int>, int, double, string>(stream);

  // /////////////////////////////////////////
  // Using specialized Matrix types
  // /////////////////////////////////////////
  cout << "\nUsing specialized Matrix types\n";
  
  // Create a matrix with integer data
  MyMatrix<int> spec_matrix {int_axis, double_axis, string_axis};
  // Print all the nodes of the string axis
  cout << "String axis knots:";
  for (auto& knot : spec_matrix.axisInfo<STRING_AXIS>()) {
    cout << " " << knot;
  }
  cout << "\n";
  // Get an iterator and fix two axes
  auto iter2 = spec_matrix.begin();
  iter2.fixAxisByValue<STRING_AXIS>("two").fixAxisByIndex<INT_AXIS>(3);
  // Print some info about each cell
  do {
    cout << "Double axis coord: " << iter2.axisIndex<DOUBLE_AXIS>() << "\n";
    cout << "Double axis knot value: " << iter2.axisValue<DOUBLE_AXIS>() << "\n";
  } while (++iter2 != spec_matrix.end());
  // Write the matrix in a string stream and then read it back
  binaryExport(stream, spec_matrix);
  auto stream_spec_matrix = myBinaryImport<int>(stream);
  // Create a matrix to keep strings
  MyMatrix<string> string_matrix = {stream_spec_matrix.axisInfoTuple()};
  
}
\endcode

*/

}