/*
 * Copyright (C) 2012-2020 Euclid Science Ground Segment
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 3.0 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifdef NPY_IMPL

#include <endian.h>
#include <sstream>
#include <boost/endian/arithmetic.hpp>
#include <ElementsKernel/Exception.h>
#include "NdArray/NdArray.h"
#include "NpyCommon.h"

namespace Euclid {
namespace NdArray {

using boost::endian::little_uint16_t;
using boost::endian::little_uint32_t;

/**
 * We write arrays following 2.0 version (32 bits header size)
 */
constexpr const uint8_t NPY_VERSION[] = {'\x02', '\x00'};

/**
 * Generate a string that represents an NdArray shape vector as a Python tuple
 * @param shape
 * @return
 *  A string with the Python representation of a tuple
 */
inline std::string npyShape(const std::vector<size_t>& shape) {
  std::stringstream shape_stream;
  shape_stream << "(";
  for (auto s : shape) {
    shape_stream << s << ',';
  }
  shape_stream << ")";
  return shape_stream.str();
}

/**
 * Endianness marker for the numpy array
 */
#if __BYTE_ORDER == __LITTLE_ENDIAN
constexpr const char *ENDIAN_MARKER = "<";
#elif __BYTE_ORDER == __BIG_ENDIAN
constexpr const char* ENDIAN_MARKER = ">";
#else
#error "__PDP_ENDIAN not supported"
#endif

/**
 * Write header
 */
template<typename T>
void writeNpyHeader(std::ostream& out, const std::vector<size_t>& shape) {
  // Serialize header as a Python dict
  std::stringstream header;
  header << "{"
         << "'descr': '" << ENDIAN_MARKER << NpyDtype<T>::str << "', 'fortran_order': False, 'shape': "
         << npyShape(shape)
         << "}";
  auto header_str = header.str();
  little_uint32_t header_len = header_str.size();

  // Pad header with spaces so the header block is 64 bytes aligned
  size_t total_length = sizeof(NPY_MAGIC) + sizeof(NPY_VERSION) + sizeof(header_len) + header_len - 1; // Keep 1 for \n
  size_t padding = 64 - total_length % 64;
  if (padding) {
    header << std::string(padding, '\x20') << '\n';
    header_str = header.str();
    header_len = header_str.size();
  }

  // Magic and version
  out.write(NPY_MAGIC, sizeof(NPY_MAGIC));
  out.write(reinterpret_cast<const char *>(&NPY_VERSION), sizeof(NPY_VERSION));

  // HEADER_LEN
  out.write(reinterpret_cast<char*>(&header_len), sizeof(header_len));

  // HEADER
  out.write(header_str.data(), header_str.size());
}

/*
 * Implementation of writeNpy
 */
template<typename T>
void writeNpy(std::ostream& out, const NdArray<T>& array) {
  writeNpyHeader<T>(out, array.shape());
  // The header already has the endian type, so just dump the content of the array
  for (auto v : array) {
    out.write(reinterpret_cast<const char *>(&v), sizeof(v));
  }
}

} // end of namespace NdArray
} // end of namespace Euclid

#endif // NPY_IMPL
